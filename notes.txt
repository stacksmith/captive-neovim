 MSGPACK decoder
 https://github.com/msgpack/msgpack/blob/master/spec.md

 A simple 'just-in-time' decoder support.  Unlike cl-messagepack we do not
 just read data and convert to some large structure to go parse.  We simply
 provide support for stream parsing logic.  Ideally, the application can
 read and build its own structures just-in-time, avoiding a layer of consing.



 Open letter to implementors of the RPC UI protocol:

 It is hard to come up with a decent protocol.  In this case, you
 started with a clean slate.  While I try not to be critical, and appreciate
 the fact that the UI protocol exists at all... it is absurdly inconsistent.

 Some questions:

 Why use messagepack at all if you are not concerned with optimization and
   performance?
 Why are response types 1 2 and not strings, as the rest of the protocol?
 Conversely, why are subpacket types strings instead of enumerations?
 Why do response and request types share the same enumeration? 0 1 2?
  There is no possible way for them to intersect.
 Why are some commands like "put" are followed by data inline while
   others like cursor_goto have data in an array?
 Why are many 'singleton' data elements inside an array of 1?
 The spec states to not assume anything about sequence of notifications.
  And yet, cursor-goto must come before put! Why is put separated from goto?
 Highlight is inconsistent...

** VIM class

Encapsulates an embedded vim connection and communication.

All vim RPC is decoded via a global cons-free msgpack decoder/parser.  Messages
are then routed to proper instances of neovim.
